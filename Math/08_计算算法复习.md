# 计算算法复习材料

## 一、算法复杂度分析

### 知识点讲解

算法复杂度分析是评估算法性能的重要方法，主要包括时间复杂度和空间复杂度。

**时间复杂度**：描述算法运行时间随输入规模增长的变化趋势，使用大O表示法：
- O(1)：常数时间，如数组访问
- O(log n)：对数时间，如二分搜索
- O(n)：线性时间，如线性搜索
- O(n log n)：线性对数时间，如归并排序、快速排序
- O(n²)：平方时间，如冒泡排序、选择排序

**空间复杂度**：描述算法额外空间需求随输入规模增长的变化趋势。

### 选择题

**题目1**：下列算法的时间复杂度为：
```python
for i in range(n):
    for j in range(n):
        print(i, j)
```
A. O(n)  B. O(n log n)  C. O(n²)  D. O(2^n)

**答案：C**

**详细分析**：
- **解题思路**：这是一个双重嵌套循环，外层循环执行n次，内层循环也执行n次，总执行次数为n×n = n²
- **关键步骤**：分析循环层数，每层循环的执行次数
- **易错点**：容易误认为是O(n)，忽略了两层循环的嵌套关系

**题目2**：二分搜索算法的时间复杂度是：
A. O(n)  B. O(log n)  C. O(n log n)  D. O(n²)

**答案：B**

**详细分析**：
- **解题思路**：每次搜索将搜索范围缩小一半，需要log₂n次操作
- **关键步骤**：理解"每次减半"的搜索过程
- **易错点**：可能误认为是O(n)，没有理解二分搜索的减半特性

### 解答题

**题目**：分析以下算法的时间复杂度：
```python
def example_function(arr):
    n = len(arr)
    for i in range(n):
        for j in range(n//2):
            print(arr[i], arr[j])
```

**解答**：
- **解题思路**：分析每层循环的执行次数
- **关键步骤**：
  1. 外层循环：执行n次
  2. 内层循环：执行n/2次
  3. 总操作数：n × (n/2) = n²/2
- **时间复杂度**：O(n²)
- **详细分析**：虽然内层循环是n/2次，但时间复杂度只关注最高次项，忽略常数因子

## 二、排序算法

### 知识点讲解

排序算法是计算机科学中的基础算法，主要分为简单排序和高效排序两类。

**简单排序算法**：
- **冒泡排序**：重复比较相邻元素，较大元素"冒泡"到末尾，时间复杂度O(n²)
- **选择排序**：每次选择最小元素放到已排序序列末尾，时间复杂度O(n²)
- **插入排序**：将元素插入到已排序序列的适当位置，时间复杂度O(n²)

**高效排序算法**：
- **快速排序**：分治策略，平均时间复杂度O(n log n)，最坏O(n²)
- **归并排序**：分治策略，时间复杂度O(n log n)，稳定排序

### 通俗讲解

想象你有一副乱序的扑克牌要整理：
- **冒泡排序**就像从牌堆底部开始，每次把最大的牌"冒泡"到最上面
- **选择排序**就像每次从剩余牌中找到最小的，放在已整理好的牌堆后面
- **插入排序**就像玩牌时整理手牌，每次把新抓的牌插入到合适位置
- **快速排序**就像找一个"基准牌"，把比它小的放左边，比它大的放右边，然后分别整理两边
- **归并排序**就像把牌分成小堆整理好，再把相邻的小堆合并成大堆

### 选择题

**题目1**：下列排序算法中，哪些是稳定的？（多选）
A. 冒泡排序  B. 选择排序  C. 插入排序  D. 快速排序

**答案：A、C**

**详细分析**：
- **解题思路**：稳定排序指相等元素的相对位置在排序后保持不变
- **关键步骤**：分析各排序算法是否保持相等元素的相对位置
- **易错点**：容易误认为快速排序是稳定的，实际上它是不稳定的

**题目2**：快速排序的平均时间复杂度是：
A. O(n)  B. O(n log n)  C. O(n²)  D. O(log n)

**答案：B**

**详细分析**：
- **解题思路**：快速排序采用分治策略，平均情况下每次分割将数组分成大致相等的两部分
- **关键步骤**：理解递归深度为log n，每层处理n个元素
- **易错点**：混淆平均情况和最坏情况，最坏情况是O(n²)

### 解答题

**题目**：实现冒泡排序算法，并分析其时间和空间复杂度。

**解答**：

**算法实现**：
```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        # 提前退出标志
        swapped = False
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                # 交换元素
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = True
        # 如果没有发生交换，说明数组已经有序
        if not swapped:
            break
    return arr
```

**复杂度分析**：
- **时间复杂度**：
  - 最坏情况：O(n²) - 数组完全逆序
  - 最好情况：O(n) - 数组已经有序（优化后）
  - 平均情况：O(n²)
- **空间复杂度**：O(1) - 原地排序
- **稳定性**：稳定排序

**优化点**：
1. 添加提前退出标志，如果某轮没有发生交换则说明已经有序
2. 记录最后交换位置，下次只需排序到该位置

## 三、搜索算法

### 知识点讲解

搜索算法用于在数据集合中查找特定元素，主要包括线性搜索和二分搜索。

**线性搜索**：遍历所有元素，时间复杂度O(n)，适用于无序数组
**二分搜索**：在有序数组中查找，时间复杂度O(log n)，效率更高

### 选择题

**题目1**：使用二分搜索的前提条件是：
A. 数组必须是无序的
B. 数组必须是有序的
C. 数组长度必须是偶数
D. 数组元素必须互不相同

**答案：B**

**详细分析**：
- **解题思路**：二分搜索依赖数组的有序性来缩小搜索范围
- **关键步骤**：理解二分搜索的工作原理 - 比较中间元素，缩小搜索范围
- **易错点**：容易忽略有序性要求

### 解答题

**题目**：实现二分搜索算法，处理边界情况。

**解答**：

**算法实现**：
```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = left + (right - left) // 2  # 防止溢出
        
        if arr[mid] == target:
            return mid  # 找到目标，返回索引
        elif arr[mid] < target:
            left = mid + 1  # 在右半部分搜索
        else:
            right = mid - 1  # 在左半部分搜索
    
    return -1  # 未找到目标
```

**边界处理**：
- **left和right的初始化**：left=0, right=len(arr)-1
- **循环条件**：left <= right（包含等于情况）
- **mid的计算**：left + (right - left) // 2 避免整数溢出
- **边界更新**：left = mid + 1, right = mid - 1

**复杂度分析**：
- **时间复杂度**：O(log n)
- **空间复杂度**：O(1)

## 四、递归思想和分治策略

### 知识点讲解

**递归**：函数调用自身解决问题，需满足：
- 有明确的递归终止条件（基准情况）
- 问题规模逐步缩小

**分治策略**：将大问题分解为子问题，分别解决后再合并结果。
经典应用：归并排序、快速排序、二分搜索

### 通俗讲解

递归就像"照镜子"：
- 你站在两面镜子之间，可以看到无穷多个自己的影像
- 每个影像都是前一个影像的"缩小版"
- 递归也是如此，每次调用都是解决一个"更小版本"的问题

分治就像"分而治之"：
- 要吃掉一整个蛋糕太难？先切成小块
- 要解决一个大问题太难？先分成几个小问题
- 解决完小问题后，再把结果"组装"成大问题的答案

### 选择题

**题目1**：递归函数 `f(n) = f(n-1) + f(n-2)` 的时间复杂度是：
A. O(n)  B. O(log n)  C. O(n²)  D. O(2^n)

**答案：D**

**详细分析**：
- **解题思路**：这是斐波那契数列的递归定义，每次调用产生两个子调用
- **关键步骤**：画递归树，每个节点产生两个子节点，深度为n
- **易错点**：容易误认为是O(n)，实际上指数级增长

### 解答题

**题目**：用递归实现斐波那契数列，并分析其时间复杂度。

**解答**：

**递归实现**：
```python
def fibonacci(n):
    # 基准情况
    if n <= 1:
        return n
    
    # 递归调用
    return fibonacci(n-1) + fibonacci(n-2)
```

**时间复杂度分析**：
- **递归树分析**：
  - 根节点：f(n)
  - 第一层：f(n-1), f(n-2)
  - 第二层：f(n-3), f(n-2), f(n-1), f(n-3)
  - ...
- **节点数量**：约2^n个节点
- **时间复杂度**：O(2^n)

**优化方案**：
```python
# 动态规划优化
def fibonacci_optimized(n):
    if n <= 1:
        return n
    
    a, b = 0, 1
    for i in range(2, n+1):
        a, b = b, a + b
    
    return b
```

**优化后复杂度**：O(n)时间，O(1)空间

## 五、动态规划基础

### 知识点讲解

动态规划是一种通过保存子问题解避免重复计算的算法设计方法。

**适用条件**：
- 重叠子问题：子问题会被重复计算
- 最优子结构：问题的最优解包含子问题的最优解

**解题步骤**：
1. 定义状态
2. 找出状态转移方程
3. 确定边界条件
4. 空间优化

### 通俗讲解

动态规划就像"记账"：
- 要计算复杂的账目，先把每笔小账记下来
- 后面要用到某个小账时，直接查账本，不用重新计算
- 这样虽然占用了一些空间（账本），但节省了大量时间

比如计算斐波那契数列：
- 不要每次都从头算起
- 把前面算过的结果保存下来
- 下次要用时直接查表

### 选择题

**题目1**：动态规划的本质是：
A. 贪心算法  B. 分治算法  C. 记忆化搜索  D. 暴力搜索

**答案：C**

**详细分析**：
- **解题思路**：动态规划通过保存子问题结果避免重复计算
- **关键步骤**：理解"记忆化"的概念
- **易错点**：容易混淆动态规划和分治算法

### 解答题

**题目**：给定一个整数数组 `nums`，找到连续子数组的最大和。

**解答**：

**问题分析**：
这是经典的"最大子数组和"问题（Kadane算法），满足动态规划的两个条件：
- 重叠子问题：计算以每个位置结尾的最大子数组和
- 最优子结构：dp[i] = max(dp[i-1] + nums[i], nums[i])

**动态规划解法**：
```python
def maxSubArray(nums):
    if not nums:
        return 0
    
    # dp[i]表示以第i个元素结尾的最大子数组和
    dp = [0] * len(nums)
    dp[0] = nums[0]
    max_sum = nums[0]
    
    for i in range(1, len(nums)):
        # 状态转移方程
        dp[i] = max(dp[i-1] + nums[i], nums[i])
        max_sum = max(max_sum, dp[i])
    
    return max_sum
```

**空间优化版本**：
```python
def maxSubArray(nums):
    if not nums:
        return 0
    
    current_sum = nums[0]
    max_sum = nums[0]
    
    for i in range(1, len(nums)):
        current_sum = max(current_sum + nums[i], nums[i])
        max_sum = max(max_sum, current_sum)
    
    return max_sum
```

**复杂度分析**：
- **时间复杂度**：O(n)
- **空间复杂度**：O(1)（优化版本）

**解题思路**：
- **关键步骤**：正确理解状态转移方程的含义
- **易错点**：容易忽略以当前元素单独成子数组的情况

## 六、图论算法基础

### 知识点讲解

图论算法处理顶点间的关系，主要包括图的遍历和最短路径算法。

**图的遍历**：
- **深度优先搜索(DFS)**：尽可能深地搜索每个分支
- **广度优先搜索(BFS)**：按层次逐层搜索

**最短路径**：
- **Dijkstra算法**：单源最短路径，时间复杂度O((V+E)logV)
- **Bellman-Ford算法**：可以处理负权边，时间复杂度O(VE)

### 选择题

**题目1**：BFS和DFS的主要区别是：
A. BFS使用栈，DFS使用队列
B. BFS使用队列，DFS使用栈
C. BFS用于无权图，DFS用于有权图
D. BFS时间复杂度更高

**答案：B**

**详细分析**：
- **解题思路**：BFS使用队列实现层次遍历，DFS使用栈实现深度遍历
- **关键步骤**：理解两种遍历方式的实现原理
- **易错点**：容易混淆栈和队列的使用

### 解答题

**题目**：实现图的深度优先搜索(DFS)和广度优先搜索(BFS)。

**解答**：

**邻接表表示的图**：
```python
from collections import deque

class Graph:
    def __init__(self):
        self.adjacency_list = {}
    
    def add_edge(self, u, v):
        if u not in self.adjacency_list:
            self.adjacency_list[u] = []
        if v not in self.adjacency_list:
            self.adjacency_list[v] = []
        self.adjacency_list[u].append(v)
        self.adjacency_list[v].append(u)
```

**DFS实现**：
```python
def dfs(self, start, visited=None):
    if visited is None:
        visited = set()
    
    visited.add(start)
    result = [start]
    
    for neighbor in self.adjacency_list.get(start, []):
        if neighbor not in visited:
            result.extend(self.dfs(neighbor, visited))
    
    return result
```

**BFS实现**：
```python
def bfs(self, start):
    visited = set()
    queue = deque([start])
    visited.add(start)
    result = []
    
    while queue:
        node = queue.popleft()
        result.append(node)
        
        for neighbor in self.adjacency_list.get(node, []):
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
    
    return result
```

**复杂度分析**：
- **DFS时间复杂度**：O(V + E)，其中V是顶点数，E是边数
- **BFS时间复杂度**：O(V + E)
- **空间复杂度**：O(V)

**应用场景**：
- **DFS**：路径查找、拓扑排序、检测环
- **BFS**：最短路径（无权图）、层次遍历

---

**复习要点总结**：
1. **复杂度分析**：掌握各种算法的时间空间复杂度
2. **排序算法**：理解算法思想，注意稳定性
3. **搜索算法**：掌握边界条件处理
4. **递归分治**：画递归树分析复杂度
5. **动态规划**：正确设计状态转移方程
6. **图论算法**：理解遍历方式的区别和应用场景

记住：算法学习的核心是理解思想，掌握方法，多加练习！